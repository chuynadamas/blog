<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="ChuyNadaMas's Personal Blog"/><link rel="canonical" href="https://chuynadamas.github.io/chuynadamas/posts/opaque-returns"/><meta name="twitter:url" content="https://chuynadamas.github.io/chuynadamas/posts/opaque-returns"/><meta name="og:url" content="https://chuynadamas.github.io/chuynadamas/posts/opaque-returns"/><title>Opaque return types in swift 🤪 | ChuyNadaMas's Personal Blog</title><meta name="twitter:title" content="Opaque return types in swift 🤪 | ChuyNadaMas's Personal Blog"/><meta name="og:title" content="Opaque return types in swift 🤪 | ChuyNadaMas's Personal Blog"/><meta name="description" content="Explanation about the opaque return types in swift 🐦"/><meta name="twitter:description" content="Explanation about the opaque return types in swift 🐦"/><meta name="og:description" content="Explanation about the opaque return types in swift 🐦"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/asteroid.ico" type="image/x-icon"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to ChuyNadaMas's Personal Blog"/></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">ChuyNadaMas's Personal Blog</a></div></header><div class="wrapper"><article><div class="content"><h1>Opaque return types in swift 🤪</h1><a class="disclaimer" href="https://www.donnywals.com/understanding-opaque-return-types-in-swift-5-1/">
    This is a rewrite of the post from Donny Wals, if you are reading this pleae see the original content at Donny Wals I'm not making any money of this blog is only my personal studies purposes.
</a><h2>Some background</h2><p>If you have spent some time with SwiftUI, you may have noticed that views in SwiftUI have a property called <code>body</code> of type <code>some View</code>. If want to go deeper please see the following <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0244-opaque-result-types.md">SE-0244</a></p><h2><code>Some</code> keyboard</h2><p>In Swift, we can use protocols to define interfaces or contracts for our objects. When something conforms to a protocol, we know that it can do certain things, or has certain properties. This means that you can writr code like this:</p><pre><code><span class="keyword">protocol</span> ListItemDisplayable {
  <span class="keyword">var</span> name: <span class="type">String</span> { <span class="keyword">get</span> }
}

<span class="keyword">struct</span> Shoe: <span class="type">ListItemDisplayable</span> {
  <span class="keyword">let</span> name: <span class="type">String</span>
}

<span class="keyword">var</span> listItem: <span class="type">ListItemDisplayable</span> = <span class="type">Shoe</span>(name: <span class="string">"a shoe"</span>)
</code></pre><br/><p>When using this <code>listItem</code> property, only the properties exposed by <code>ListItemDisplayable</code> are exposed to us. This is especially useful when you want to have an array of items that are <code>ListItemDisplayable</code> where concrete types can be more than just <code>Shoe</code></p><br/><pre><code><span class="keyword">struct</span> Shoe: <span class="type">ListItemDisplayable</span> {
  <span class="keyword">let</span> name: <span class="type">String</span>
}

<span class="keyword">struct</span> Shorts: <span class="type">ListItemDisplayable</span> {
  <span class="keyword">let</span> name: <span class="type">String</span>
}

<span class="keyword">var</span> mixedList: [<span class="type">ListItemDisplayable</span>] = [<span class="type">Shoe</span>(name: <span class="string">"a shoe"</span>),
                                        <span class="type">Shorts</span>(name: <span class="string">"a pair of shorts"</span>)]
</code></pre><br/><p>The compiler treats our <code>Shoe</code> and <code>Shorts</code> objects as <code>ListItemDisplayable</code>, so users of this list won't know whether they're dealing with shoes, shorts, jeans or anything else. All they know is that whatever is in the array can be displayed in a list because ir conforms to <code>ListDisplayable</code>.</p><br/><h2>Opaque result types for protocols with associated types</h2><p>The flexible shown in the previous section is really cool, but we can push our code further:</p><br/><pre><code><span class="keyword">protocol</span> ListDataSource {
  <span class="keyword">associatedtype</span> ListItem: <span class="type">ListItemDisplayable</span>

  <span class="keyword">var</span> items: [<span class="type">ListItem</span>] { <span class="keyword">get</span> }
  <span class="keyword">var</span> numberOfItems: <span class="type">Int</span> { <span class="keyword">get</span> }
  <span class="keyword">func</span> itemAt(<span class="keyword">_</span> index: <span class="type">Int</span>) -&gt; <span class="type">ListItem</span>
}
</code></pre><br/><p>The above defines a <code>ListDataSource</code> that holds some list of an item that conforms to <code>ListItemDisplayable</code>. We can use objects that conform to this protocol as data source objects for table views, or collection views which is preatty neat.</p><br/><p>We can define a view model generator object that will, depending on what kind of items we pass it, generate a <code>ListDataSource:</code></p><br/><pre><code><span class="keyword">struct</span> ShoesDataSource: <span class="type">ListDataSource</span> {
  <span class="keyword">let</span> items: [<span class="type">Shoe</span>]
  <span class="keyword">var</span> numberOfItems: <span class="type">Int</span> { items.<span class="property">count</span> }

  <span class="keyword">func</span> itemAt(<span class="keyword">_</span> index: <span class="type">Int</span>) -&gt; <span class="type">Shoe</span> {
    <span class="keyword">return</span> items[index]
  }
}

<span class="keyword">struct</span> ViewModelGenerator {
  <span class="keyword">func</span> listProvider(for items: [<span class="type">Shoe</span>]) -&gt; <span class="type">ListDataSource</span> {
    <span class="keyword">return</span> <span class="type">ShoesDataSource</span>(items: items)
  }
}
</code></pre><br/><p>However, this code doesn't compile because <code>ListDataSource</code> is a protocol with associated type constraints. We could fix this by specifiying <code>ShoesDataSource</code> as the return type instead of <code>ListDataSource</code>, but this would expose an implementation detail that we wanto to hide from users of the <code>ViewModelGenerator</code>.</p><br/><p>Callers of <code>listProvider(for:)</code> only really need to know is that we're going to return a <code>ListDataSource</code> from this method. We can rewrite the generators as follos make our code compile:</p><br/><pre><code><span class="keyword">struct</span> ViewModelGenerator {
  <span class="keyword">func</span> listProvider(for items: [<span class="type">Shoe</span>]) -&gt; <span class="keyword">some</span> <span class="type">ListDataSource</span> {
    <span class="keyword">return</span> <span class="type">ShoesDataSource</span>(items: items)
  }
}
</code></pre><br/><p>By using the <code>some</code> keyword, the compiler can enforce a couple of things while hiding them from the caller of <code>listProvides(for:)</code>:</p><br/><ul class="ul-normal">
    <li class="li-normal">We return something that conforms to<code>ListDataSource</code></li>
    <li class="li-normal">The returned object's associated type matches any requirements that are set by<code>ListDataSource</code></li>
    <li class="li-normal">We always return the same type from<code>listProvider(for:)</code></li>
</ul><br/><br/><p>Especially this last point is interesting. In Swift, we rely on the compiler to do a lot of compile-time type checks to help us write safe and consistent code. And in turn, the compiler uses all of this information about types to optimize our code to ensure it runs as fast as possible. Protocols are often a problem for the compiler because they imply a certain dynamism that makes it hard for the compiler to make certain optimizations at compile time which means that we’ll take a <em>(very small)</em> performance hit at runtime because the runtime will need to do some type checking to make sure that what’s happening is valid.</p><br/><p>Because the Swift compiler can enforce the things listed above, it can make the same optimizations that it can when we would use concrete types, yet we have the power of hiding the concrete type from the caller of a function or property that returns an opaque type.</p><br/><h2>Opaque result types and Self requirements</h2><p>Because the compiler can enforce type constraints compile time, we can do other interesting things. For example, we can compare items that are returned as opaque types while we cannot do the same with protocols. Let’s look at a simple example:</p><br/><pre><code><span class="keyword">protocol</span> ListItemDisplayable: <span class="type">Equatable</span> {
  <span class="keyword">var</span> name: <span class="type">String</span> { <span class="keyword">get</span> }
}

<span class="keyword">func</span> createAnItem() -&gt; <span class="type">ListItemDisplayable</span> {
  <span class="keyword">return</span> <span class="type">Shoe</span>(name: <span class="string">"a comparable shoe:</span> \(<span class="type">UUID</span>().<span class="property">uuidString</span>)<span class="string">"</span>)
}
</code></pre><br/><p>The above doesn’t compile because <code>Equatable</code> has a <code>Self</code> requirement. It wants to compare two instances of <code>Self</code> where both instances are of the same type. This means that we can’t use <code>ListItemDisplayable</code> as a regular return type, because a protocol on its own has no type information. We need the <code>some</code> keyword here so the compiler will figure out and enforce a type for <code>ListItemDisplayable</code> when we call <code>createAnItem():</code></p><br/><pre><code><span class="keyword">func</span> createAnItem() -&gt; <span class="keyword">some</span> <span class="type">ListItemDisplayable</span> {
  <span class="keyword">return</span> <span class="type">Shoe</span>(name: <span class="string">"a comparable shoe:</span> \(<span class="type">UUID</span>().<span class="property">uuidString</span>)<span class="string">"</span>)
}
</code></pre><br/><p>The compiler can now determine that we’ll always return <code>Shoe</code> from this function, which means that it knows what <code>Self</code> for the item that’s returned by <code>createAnItem()</code>, which means that the item can be considered <code>Equatable</code>. This means that the following code can now be used to create two items and compare them:</p><br/><pre><code><span class="keyword">let</span> left = <span class="call">createAnItem</span>()
<span class="keyword">let</span> right = <span class="call">createAnItem</span>()

<span class="call">print</span>(left == right)
</code></pre><br/><p>What’s really cool here is that both <code>left</code> and <code>right</code> hide all of their type information. If you call <code>createAnItem()</code>, all you know is that you get a <code>list</code> item back. And that you can compare that list item to other list items returned by the same function.</p><br/><h2>Opaque return types as reverse generics</h2><p>The Swift documentation on opaque result types sometimes refers to them as reverse generics which is a pretty good description. Before opaque result types, the only way to use protocols with associated types as a return type would have been to place the protocol on a generic constraint for that method. The downside here is that the caller of the method gets to decide the type that’s returned by a function rather than letting the function itself decide:</p><br/><pre><code><span class="keyword">protocol</span> ListDataSource {
  <span class="keyword">associatedtype</span> ListItem: <span class="type">ListItemDisplayable</span>

  <span class="keyword">var</span> items: [<span class="type">ListItem</span>] { <span class="keyword">get</span> }ƒ
  <span class="keyword">var</span> numberOfItems: <span class="type">Int</span> { <span class="keyword">get</span> }
  <span class="keyword">func</span> itemAt(<span class="keyword">_</span> index: <span class="type">Int</span>) -&gt; <span class="type">ListItem</span>

  <span class="keyword">init</span>(items: [<span class="type">ListItem</span>])
}

<span class="keyword">func</span> createViewModel&lt;T: <span class="type">ListDataSource</span>&gt;(for list: [<span class="type">T</span>.<span class="type">ListItem</span>]) -&gt; <span class="type">T</span> {
  <span class="keyword">return</span> <span class="type">T</span>.<span class="keyword">init</span>(items: list)
}

<span class="keyword">func</span> createOpaqueViewModel&lt;T: <span class="type">ListItemDisplayable</span>&gt;(for list: [<span class="type">T</span>]) -&gt; <span class="keyword">some</span> <span class="type">ListDataSource</span> {
  <span class="keyword">return</span> <span class="type">GenericViewModel</span>&lt;<span class="type">T</span>&gt;(items: list)
}

<span class="keyword">let</span> shoes: <span class="type">GenericViewModel</span>&lt;<span class="type">Shoe</span>&gt; = <span class="call">createViewModel</span>(for: shoeList)
<span class="keyword">let</span> opaqueShoes = <span class="call">createOpaqueViewModel</span>(for: shoeList)
</code></pre><br/><p>Both methods in the preceding code return the exact same <code>GenericViewModel</code> in this example. The main difference here is that in the first case, the caller decides that it wants to have a <code>GenericViewModel&lt;Shoe&gt;</code> for its list of shoes, and it will get a concrete type back of type <code>GenericViewModel&lt;Shoe&gt;</code>. In the opaque example, the caller only decides that it wants some <code>ListDataSource</code> that holds its list of <code>ListItemDisplayable</code> items. This means that the implementation of <code>createOpaqueViewModel</code> can now decide what it wants to do. In this case, we chose to return a generic view model. We could also have chosen to return a different kind of view model instead, all that matters is that we always return the same type and that it conforms to <code>ListDataSource</code>.</p><h2>Using opaque return types in your projects</h2><p>While I was studying opaque return types and trying to come up with examples for this post, I noticed that it’s not really easy to come up with reasons to use opaque return types in common projects. In SwiftUI they serve a key role, which might make you believe that opaque return types are going to be commonplace in a lot of projects at some point.</p><br/><p>Personally, I don’t think this will be the case. Opaque return types are a solution to a very specific problem in a domain that most of us don’t work on. If you’re building frameworks or highly reusable code that should work across many projects and codebases, opaque result types will interest you. You’ll likely want to write flexible code based on protocols with associated types where you, as the builder of the framework, have full control of the concrete types that are returned without exposing any generics to your callers.</p><br/><p>Another consideration for opaque return types might be their runtime performance. As discussed earlier, protocols sometimes force the compiler to defer certain checks and lookups until runtime which comes with a performance penalty. Opaque return types can help the compiler make compile-time optimizations which is really cool, but I’m confident that it won’t matter much for most applications. Unless you’re writing code that really has to be optimized to its core, I don’t think the runtime performance penalty is significant enough to throw opaque result types at your codebase. Unless, of course, it makes a lot of sense to you. Or if you’re certain that in your case the performance benefits are worth it.</p><br/><p>What I’m really trying to say here is that protocols as return types aren’t suddenly horrible for performance. In fact, they sometimes are the only way to achieve the level of flexibility you need. For example, if you need to return more than one concrete type from your function, depending on certain parameters. You can’t do that with opaque return types.</p><br/><p>This brings me to quite possibly the least interesting yet easiest way to start using opaque return types in your code. If you have places in your code where you’ve specified a protocol as return type, but you know that you’re only returning one kind of concrete type from that function, it might make sense to use an opaque return type instead.</p><h2>In summary</h2><p>You learned that opaque return types can act as a return type if you want to return an object that conforms to a protocol with associated type constraints. This works because the compiler performs several checks at compile time to figure out what the real types of a protocol’s associated types are. You also saw that opaque return types help resolve so-called Self requirements for similar reasons. Next, you saw how opaque result types act as reverse generics in certain cases, which allows the implementer of a method to determine a return type that conforms to a protocol rather than letting the caller of the method decide.</p><br/><blockquote><p>With great power comes great responsibility -- Uncle Ben 🕸</p></blockquote></div><span>Tagged with: </span><ul class="tag-list"><li class="tag variant-a"><a href="/tags/article">Article</a></li><li class="tag variant-c"><a href="/tags/swift">Swift</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>